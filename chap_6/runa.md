# 6 - 서버 사이드 리액트

## 1. 클라이언트 사이드 렌더링의 한계

### 1) 검색 엔진 최적화

CSR 방식은 검색 엔진 크롤러가 콘텐츠를 올바르게 색인하는 데 어려움을 준다.

- 구글 등 현대적인 크롤러는 자바스크립트를 실행할 수 있지만, 모든 크롤러가 동일하게 동작하지는 않는다.
- 서버가 전송하는 초기 HTML은 비어 있고 자바스크립트가 실행된 후에야 콘텐츠가 채워지기 때문에, 크롤러가 내용을 읽지 못하고 빈 페이지로 인식할 위험이 있다.

### 2) 성능

- 초기 HTML 로드 후 자바스크립트 번들을 다운로드, 파싱, 실행한 뒤에야 비로소 데이터 페칭이 시작된다. 이 과정이 순차적으로 일어나면서 화면이 뜨기까지 긴 시간이 걸린다.
- CPU 성능이 낮은 기기에서는 자바스크립트 실행 속도가 느려 사용자 경험이 악화된다.
- 리액트와 리액트 DOM 라이브러리만 합쳐도 약 136KB에 달하며, 실제 앱 코드를 실행하기 전에 이들을 모두 다운로드해야 한다.

```tsx
const Home = () => {
  const [data, setData] = useState([]);

  useEffect(() => {
    // 자바스크립트가 로드되고 실행된 후에 비동기 요청 시작
    fetch("https://api.example.com/data")
      .then((res) => res.json())
      .then((data) => setData(data));
  }, []);

  return (
    <ul>
      {data.map((item) => (
        <li key={item.id}>{item.title}</li>
      ))}
    </ul>
  );
};
```

### 3) 보안

- **CSRF 위협:** 클라이언트와 서버가 서로를 신뢰하기 위한 토큰을 사전에 공유하기 어렵다.
- 서버 사이드 렌더링을 사용하면 서버에서 직접 보안 토큰을 생성하여 HTML에 주입할 수 있다. 클라이언트는 이 토큰을 다시 서버로 보내 양방향 계약을 설정하고 요청의 정당성을 검증할 수 있다.

## 2. 서버 렌더링

- **FMP 시간 단축:** 서버가 이미 완성된 마크업을 보내기 때문에 사용자는 자바스크립트가 다운로드되고 실행될 때까지 기다리지 않고 즉시 콘텐츠를 볼 수 있다.
- **접근성 개선:** 저전력 기기나 느린 네트워크 환경에서도 기본 콘텐츠가 포함된 HTML을 먼저 수신하므로 사용자 경험이 균일하게 유지된다.
- **SEO 최적화:** 크롤러가 사이트의 완성된 구조와 콘텐츠를 즉시 읽을 수 있어 색인 생성이 용이하다.
- 기본 콘텐츠와 기능을 먼저 제공한 뒤, 자바스크립트를 통해 고급 기능을 추가하는 방식으로 웹 표준에 부합하는 설계를 가능하게 한다.

## 3. 하이드레이션

서버에서 온 정적 HTML은 이벤트 리스너가 없는 상태이다. 이를 인터랙티브한 애플리케이션으로 만드는 과정이 하이드레이션이다.

- **동작 과정**
  1. 브라우저가 HTML을 그리는 동안 리액트 코드와 컴포넌트 로직이 담긴 자바스크립트 번들을 다운로드
  2. 리액트가 `hydrateRoot` 함수를 사용하여 기존 DOM 요소에 이벤트 핸들러를 연결하고 내부 상태를 동기화
- 서버에서 생성된 HTML 구조와 클라이언트 리액트 컴포넌트의 구조가 반드시 일치해야 한다.
  - 두 구조가 다르면 리액트가 DOM 엘리먼트를 올바르게 인식하지 못해 하이드레이션 오류가 발생하거나 예기치 않은 동작을 초래한다.

### 1) 한계

- 사용자가 화면을 보고 있음에도 불구하고, 자바스크립트 번들을 다시 읽고 전체 페이지를 리렌더링하듯 이벤트 리스너를 붙이는 과정에서 많은 비용이 소모된다. 이로 인해 콘텐츠 표시 시점과 실제 상호 작용 가능 시점 사이에 간극이 발생한다.

### **2) 재개 가능성**

서버가 렌더링을 멈춘 지점부터 클라이언트가 그대로 이어서 시작하는 방식

- 초기 마크업과 함께 인터랙티브 동작에 필요한 정보를 직렬화하여 전송한다. 클라이언트는 별도의 하이드레이션 과정 없이 서버가 제공한 내용을 역직렬화하여 즉시 반응할 수 있다.
- 재개 가능성은 인터랙티브 시간을 획기적으로 줄여주지만, 구현 복잡성이 높다.

## 4. 서버 렌더링 작성

### 1) 클라이언트 전용 앱에 SSR 수동 추가하기

수동 구현의 핵심은 서버가 리액트 컴포넌트를 해석하여 HTML 문자열로 변환한 뒤, 이를 클라이언트에 전송하는 것이다.

- **ReactDOMServer.renderToString:** 리액트 컴포넌트를 정적인 HTML 문자열로 변환하는 핵심 함수
- 웹 프레임워크를 사용하여 모든 경로에 대한 요청을 처리하고, 변환된 HTML 문자열을 응답 본문에 삽입한다.

```tsx
const express = require("express");
const ReactDOMServer = require("react-dom/server");
const App = require("./src/App");

const app = express();

app.get("*", (req, res) => {
  // 1. 리액트 컴포넌트를 HTML 문자열로 변환
  const html = ReactDOMServer.renderToString(<App />);

  // 2. 완성된 HTML 마크업 전송
  res.send(`
    <!DOCTYPE html>
    <html>
      <head><title>SSR 예시</title></head>
      <body>
        <div id="root">${html}</div>
        <script src="/static/js/main.js"></script>
      </body>
    </html>
  `);
});

app.listen(3000);
```

- 서버로부터 전송된 마크업을 브라우저에서 확인하면 실제 컴포넌트 구조가 담긴 HTML을 확인할 수 있다.

### 2) 하이드레이션

- 서버가 보낸 HTML은 정적이기 때문에, 브라우저에서 자바스크립트 번들이 로드된 후 이를 인터랙티브한 상태로 전환하는 과정이 필요하다.
- **hydrateRoot:** `react-dom/client`에서 제공하는 함수로, 서버에서 생성된 HTML 구조를 유지하면서 리액트의 이벤트 리스너와 상태 관리 로직을 연결한다.

```tsx
import React from "react";
import { hydrateRoot } from "react-dom/client";
import App from "./App";

// 서버에서 렌더링된 HTML을 기반으로 인터랙티브 앱으로 전환
hydrateRoot(document.getElementById("root"), <App />);
```

## 5. 리액트 서버 렌더링 API 상세

### 1) renderToString

리액트 컴포넌트를 즉시 HTML 문자열로 변환

- 리액트 엘리먼트 트리를 탐색하여 정적인 HTML 문자열을 생성한다. `JSX -> createElement -> React Element -> renderToString -> HTML`의 흐름을 따른다.
- 호출 즉시 결과값이 반환된다.
- **단점**
  1. 대규모 앱에서 렌더링 시간이 길어지면 서버의 이벤트 루프를 점유하여 다른 요청을 처리하지 못하게 만든다.
  2. 전체 HTML이 완성될 때까지 클라이언트는 아무런 데이터도 받지 못하므로 첫 번째 바이트 시간이 늦어진다.
  3. 완성된 전체 HTML 문자열을 메모리에 보관해야 하므로 부하가 크다.

### 2) renderToPipeableStream

리액트 18에서 도입된 API로, 리액트 컴포넌트를 `Node.js` 스트림으로 렌더링

- 전체 HTML을 한꺼번에 보내는 대신, 준비되는 대로 청크 단위로 쪼개어 전송한다.
- 비동기 데이터 페칭을 수행하는 `Suspense` 경계를 완벽하게 처리한다. 데이터가 준비되지 않은 부분은 Fallback을 먼저 보내고, 데이터가 로드되면 해당 부분의 HTML을 나중에 스트리밍하여 갈아끼운다.
- 클라이언트 측 리액트가 로드되기 전이라도, 서버가 보낸 인라인 스크립트가 DOM 내의 `\<template\>\` 엘리먼트를 활용해 Fallback을 실제 콘텐츠로 즉시 교체한다.

```tsx
const { pipe } = ReactDOMServer.renderToPipeableStream(<App />, {
  onShellReady() {
    res.setHeader("Content-Type", "text/html");
    pipe(res); // 응답 스트림에 직접 파이핑
  },
});
```

### 3) renderToReadableStream

`renderToPipeableStream`과 유사하지만, Node.js 전용 스트림 대신 `Web Streams API`를 사용한다.

- Cloudflare Workers, Deno, 브라우저 환경 등 최신 웹 표준 스트림을 사용하는 곳에 적합하다.
- Promise 기반의 `read()`, `write()` 메서드를 사용하며 표준화된 인터페이스를 제공한다.

| **구분**      | **renderToString**      | **renderToPipeableStream** | **renderToReadableStream**  |
| ------------- | ----------------------- | -------------------------- | --------------------------- |
| **반환 타입** | HTML 문자열             | Node.js Stream             | Web Stream (ReadableStream) |
| **동작 방식** | 동기식 (차단 발생)      | 비동기식 (스트리밍)        | 비동기식 (스트리밍)         |
| **Suspense**  | 지원 불가 (즉시 렌더링) | **완벽 지원**              | **완벽 지원**               |
| **권장 환경** | 단순 SEO, 소규모 앱     | 일반적인 Node.js 서버      | Edge Runtime, Deno 등       |

## 6. 프레임워크 활용의 필요성

많은 라이브러리가 스트리밍 방식을 완벽히 지원하지 않아 직접 구현 시 호환성 문제를 해결하기 매우 까다롭지만, 프레임워크는 이를 안전하게 처리할 수 있는 표준화된 환경과 최적화된 설정을 제공하므로 가장 합리적인 선택이다.

### 1) 복잡성과 보안 문제

- 서버는 여러 클라이언트의 요청을 동시에 처리한다. 전역 변수나 잘못된 캐싱 전략을 사용하면 사용자의 민감한 정보가 다른 사용자에게 전달되는 보안 사고가 발생할 수 있다.
- 검증된 프레임워크는 사용자별로 격리된 데이터 페칭 방식을 강제하여 이러한 문제를 미리 방지한다.

### 2) 성능 최적화와 개발자 경험

- 페이지 단위로 번들을 쪼개어 필요한 시점에만 로드함으로써 초기 로딩 속도를 개선한다.
- 개발자가 로우 레벨의 서버 렌더링 인프라 구축에 시간을 쏟는 대신, 실제 애플리케이션의 핵심 기능을 구현하는 데 집중할 수 있게 해준다.
