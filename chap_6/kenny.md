https://www.youtube.com/watch?v=kUs-fH1k-aM

# 6.1 CSR의 한계

## 6.6.1 SEO 최적화

크롤러가 JS를 실행하지 않아 콘텐츠를 색인하기 어렵다.

## 6.1.2 성능

앱이 클라이언트에서 렌더링되기에 느린 네트워크나 낮은 성능 기기에서 문제를 겪을 수 있다. 서버에서 JS를 실행하고 미리 만들어놓은 마크업을 클라에 전송하면 부담을 줄일 수 있다.

또한 SEO 측면에서의 이점도 존재한다.

전체 사용자 경험이 클라이언트 사이드 JS로만 구성되는 건 웹의 설계 의도에 부합하지 않으며, JS의 역할은 웹 페이지를 보완해 개선하는 것이지 그 자체가 되는게 아니다.

<aside>

    💡 마크업의 역할을 JS에만 의존하는게 부적절하다고 짚고있는 것 같습니다

</aside>

![image.png](attachment:0cc8c2a0-e7eb-4b6d-a835-0f281c0040d4:image.png)

CSR에서의 네트워크 워터폴. SSR에서는 JS 다운로드 전에 렌더링된 HTML을 클라이언트에 스트리밍한다. 렌더링 후 관련 JS를 읽어들이는 과정을 하이드레이션이라고 한다.

![image.png](attachment:e0f1b961-f72a-42b5-9b57-7e7818974f8c:image.png)

![image.png](attachment:9f3329d5-6333-4f1c-868e-642932b5ea74:image.png)

## 6.1.3 보안

CSR은 모든 코드가 브라우저로 다운로드되어 CSRF같은 공격에 취약하다. 물론 방어는 여러 방법으로 가능하지만 서버 제어가 가능한 상황이면 SSR을 추가하면 좋다.

# 6.2 SSR의 부상

## 6.2.1 SSR의 장점

- FCP(First Contentful Paint)가 빨라짐
  - 이걸 왜 “최초 의미 있는 페인트”라고 길게 표현햇을까요.. 다른 뜻인가?
- 접근성 개선 (스크린리더 같은 접근성 X)
  - 저성능, 저전력 기기 환경에서 나은 퍼포먼스
- SEO 개선
- 보안 향상

SSR된 HTML은 상호 작용이 부족하다. 필요한 JS를 HTML 마크업에 “촉촉”하게 공급해줘야 한다.

# 6.3 하이드레이션

하이드레이션은 SSR 결과물인 정적 HTML에 이벤트 리스너와 JS 기능을 추가하는 프로세스다.

## 6.3.1 하이드레이션에 대한 비판

일부는 하이드레이션이 필요 이상으로 느리다며 resumability(재개 가능성)을 대안으로 꼽는다. SSR 결과물로 HTML을 렌더링한 후 JS 번들을 다운로드, 이벤트 리스너를 추가해 클라이언트를 효과적으로 “리렌더링”해야한다.

![image.png](attachment:d39ffbf4-81f4-4982-9e03-f0a78c56281e:image.png)

![image.png](attachment:1caca5de-246d-454f-9b1b-bb099e3e3ad9:image.png)

resumability를 활용하면 전체 앱이 서버에서 렌더링되고, 브라우저로 스트리밍된다. 모든 인터렉티브 동작이 직렬화되어 전송된다. 하이드레이션 없이 역직렬화 후 반응한다. TTI(Time to Interactive)가 짧아진다.

구현 복잡성이 증가하는 트레이드오프가 존재한다.

# 6.4 SSR 작성

CSR 앱이 있을 때 SSR을 추가하려면 Next.js나 Remix를 사용하면 된다.

# 6.5 리액트의 SSR API

## 6.5.1 renderToString

리액트의 SSR API로, 서버에서 리액트 컴포넌트를 HTML 문자열로 렌더링할 때 사용한다. 이 HTML 문자열을 클라이언트에 응답으로 보낸다.

동기식이라 이벤트 루프를 차단하고 서버가 응답하지 않게 만든다. 대규모 앱에서 문제가 될 수 있다.

또한 renderToString은 스트리밍을 지원하지 않아 클라이언트 전송 시 HTML 문자열 전체를 생성해야한다. TTFB(Time to First Byte)가 느려지고 클라이언트 HTML 수신 시작까지 더 오랜 시간이 걸린다.

대안으로 renderToPipeableStream, renderToReadableStream API를 제공한다.

## 6.5.2 renderToPipeableStream

리액트 18에 도입된 SSR API다. 응답 객체로 파이프할 수 있는 스트림을 반환, HTML 렌더링 방식을 더 세밀하게 제어할 수 있어 더 쉽게 Node.js 스트림과 통합된다.

SSR 중 비동기 데이터 페치를 처리하는 Suspense를 지원한다. 스트리밍이 가능하며, HTML 청크를 클라이언트에 비동기적으로 전송해 지연 없는 점진적 데이터 전달이 가능하다.

Node.js 스트림을 반환한다.

### Node.js 스트림

출발지에서 목적지로 흐르는 흐름을 나타낸다. 데이터 흐름의 특성, 방향에 따라 네 가지 종류로 분류할 수 있다.

- 읽기 가능 스트림 - 읽을 수 있는 데이터 출처, data, end, error 등의 이벤트를 발생시킴
- 쓰기 가능 스트림 - 데이터를 쓸 수 있는 대상, write(), end() 같은 메서드 제공
- 양방향 스트림 - 읽기 쓰기 가능, 소켓이나 통신 채널에 사용됨
- 변환 스트림 - 데이터가 흐르는 동안 데이터 변환을 수행하는 양방향 스트림

Node.js 스트림은 스트림 간 데이터 파이프가 가능한데, 읽기 가능 스트림 출력을 쓰기 가능 스트림의 인풋으로 연결하여 흐름이 원활해진다. 실제 리액트 SSR도 이렇게 동작한다.

### 실제로 어떻게 동작하는지?

- **초기 응답:** 서버는 Suspense 폴백과 빈 자리를 나타내는 주석 노드(ID 포함)가 담긴 HTML을 먼저 전송
- **연결 유지:** HTTP 응답을 끝내지 않고 스트림(renderToPipeableStream)을 통해 연결을 열어둠.
- **비동기 렌더링:** 서버는 백그라운드에서 데이터를 페칭하며, 준비가 끝난 컴포넌트부터 HTML 조각으로 만듦.
- **추가 전송:** 생성된 **HTML 조각 + 교체용 실행 스크립트**를 열려 있는 스트림에 즉시 write (FIFO)
- **실시간 교체:** 브라우저 파서가 스트림을 읽다가 </script>를 만나는 순간(정확히 말하면 완전히 열리고 닫힌 script 태그), 즉시 실행하여 폴백을 실제 콘텐츠로 갈아끼움.

위 과정을 통해 SSR이 이루어진다. 하이드레이션은 중간중간 JS만 준비되면 스트리밍 파이프라인 옆에서 대기하다가, HTML 조각이 준비되는대로 이루어준다.

여기서 하이드레이션 스크립트는 (리액트 번들 스크립트) 보통 HTML의 `<head>`나 `<body>` 최상단에 `<script src="..." async>` 또는 `defer` 형태로 위치한다.

때문에 브라우저 파서는 하이드레이션 스크립트를 다운로드하고, 동시에 스트리밍 HTTP 연결도 수행하여 이 두 과정이 동시에 일어난다.

이 부분을 좀 더 자세히 보면, 브라우저는 일단 하이드레이션 스크립트를 다운로드 받으면 즉시 실행한다. 하이드레이션 스크립트는 실행된 시점의 DOM(스트리밍이 끝났던, 아직 하는 중이던)을 보고, 이미 준비된 컨텐츠는 하이드레이션을 수행하고 아직 Suspense 상태인 컨텐츠는 하이드레이션을 펜딩한다.

이를 위해 브라우저는 DOM 조작을 감지하는 MutationObserver와 전역 큐를 사용한다.

**이 관점에서 하이드레이션 에러에 대해**

여기서 하이드레이션 에러를 더 잘 이해할 수 있는데, 하이드레이션을 시도하는 리액트 번들은 서버에서 생성한 HTML 형상과 현재 바라볼 HTML 형상이 같길 기대한다.

서버에서 <div>안녕</div>를 구워서 write를 했는데, 클라에서 <div>바이</div>가 있는 상황인 것임.

- **시간/날짜:** 서버는 '오후 11시'에 HTML을 구웠는데, 스트리밍되어 브라우저에 도착해 하이드레이션될 때는 '오후 11시 1초'가 된 경우.
- **브라우저 전용 API:** 서버 컴포넌트에서 `window`나 `localStorage`에 접근하려 할 때 (서버에는 이런 게 없으므로 결과물이 달라짐).
- **잘못된 HTML 구조:** `p` 태그 안에 `div`를 넣는 등 브라우저가 자동으로 HTML 구조를 보정해버리는 경우 (서버가 보낸 원본과 브라우저 파서가 보정한 결과가 달라짐).

(알게된 점: next의 use client는 csr이 아니다.)

## 6.5.3 renderToReadableStream

브라우저도 스트림을 지원한다. 네트워크 요청, 미디어 스트리밍, 데이터 처리 작업에서 스트리밍 데이터를 처리한다. Node.js 스트림과 달리 프로미스 기반이며 클라이언트 작업에 맞게 조정되었다.

리액트는 브라우저 스트림, Node.js 스트림 둘 다 지원하기 위해 각 함수가 있다.

## 6.5.4 언제 무엇을 사용?

상황에 따라 다르고 그냥 프레임워크를 쓰자.

# 6.6 직접 구현하지 마세요

Next.js나 Remix를 쓰자.
