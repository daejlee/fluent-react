# 4 - 재조정

## 1. 재조정이란?

가상 DOM은 우리가 원하는 UI 상태의 청사진이며, 재조정은 이 청사진을 호스트 환경의 실제 UI로 구체화하는 프로세스이다.

### **리액트 엘리먼트**

- JSX는 `React.createElement` 호출로 변환되며, `type`, `props`, `children` 구조를 가진 불변 객체 트리를 반환한다.
- 이 객체 트리는 실제 DOM이 아닌, 개발자가 의도한 UI의 선언적 설명이다.

### **렌더링 전략**

- 리액트는 가상 DOM 트리를 실제 DOM에 반영할 때 최소한의 DOM API만 호출하도록 설계되었다.
- 변경 사항을 일괄 처리하여 실제 DOM 조작 횟수를 줄이는 것이 성능 최적화의 핵심이다.

## 2. 일괄 처리 (Batching)

브라우저의 `DocumentFragment`처럼 리액트도 여러 업데이트를 모아 한 번에 처리하여 리플로우와 리페인트를 최소화한다.

**상태 업데이트 최적화 동작**

- 핸들러 내에서 `setCount`를 연달아 3번 호출하더라도 실제 DOM이 3번 변경되는 것이 아니다.
- 리액트는 변경 사항을 모아서 최종 연산 결과를 계산한 뒤, 실제 DOM을 단 한 번만 업데이트한다.

**내부 연산 프로세스**

- 효율적인 일괄 처리를 위해 리액트는 현재 파이버 트리를 기반으로 작업용 트리를 새로 구축하여 변경된 상태를 적용한다.
- 이후 두 트리 간의 차이를 분석하여 실제 DOM에 반영해야 할 최소한의 변경 사항만 도출해낸다.

## 3. 스택 재조정자

스택 재조정자의 가장 큰 문제는 **우선순위가 없다**는 것이다.
모든 업데이트가 공평하게 처리되다 보니 다음과 같은 병목 현상이 발생한다.

- **렌더링 차단:** `ExpensiveComponent`처럼 무거운 연산이 시작되면, 완료될 때까지 브라우저의 모든 작업이 중단된다.
- **입력 지연:** 사용자가 텍스트를 입력해도 무거운 연산에 밀려 화면에 글자가 늦게 나타나는 버벅임이 발생한다.
- **우선순위 부재:** 좋아요 수 업데이트(낮은 중요도)가 사용자 입력(높은 중요도)보다 먼저 들어오면, 입력 작업은 뒤로 밀린다.

```tsx
function Form() {
  const [text, setText] = useState("");

  const handleChange = (e) => {
    // 1. 상태 업데이트 발생
    setText(e.target.value);
  };

  return (
    <>
      <input value={text} onChange={handleChange} />
      {/* 2. 스택 재조정자는 아래 컴포넌트를 끝낼 때까지 
             위 input의 다음 타이핑 입력을 처리하지 못하고 멈춤. */}
      <ExpensiveComponent />
    </>
  );
}
```

- 스택 구조 때문에 사용자 경험이 저하된다.
- 특정 작업을 일시 중지, 재사용, 취소하거나 우선순위를 부여할 수 있는 새로운 아키텍처가 필요해졌고, 이것이 바로 파이버의 등장 배경이다.

## 4. 파이버 재조정자

### 1) 파이버란?

- 파이버는 재조정 프로세스에서 작업을 처리하는 최소 단위이다.
- 리액트 엘리먼트는 한 번 쓰고 버려지는 임시 객체지만, 파이버는 컴포넌트의 상태, 자료를 저장하며 오랫동안 유지되는 인스턴스이다.
- 특정 시점의 실제 컴포넌트 트리를 나타낸다.

### 2) 데이터 구조로서의 파이버

파이버 노드는 컴포넌트의 정보와 트리 구조를 연결하는 메타데이터를 포함한다.

- **주요 속성**
  - **태그:** 컴포넌트의 유형(함수형, 클래스형, 호스트 컴포넌트 등)을 식별하는 숫자 식별자이다.
  - **타입:** 해당 파이버가 나타내는 함수나 클래스 자체를 의미한다.
  - **상태 노드:** 컴포넌트의 인스턴스나 실제 지역 상태를 참조한다.
  - **트리 순회 포인터:** 부모, 자식, 형제를 가리키는 연결 리스트 구조를 통해 트리를 탐색한다.

### 3) 더블 버퍼링 메커니즘

리액트는 그래픽 알고리즘인 더블 버퍼링을 차용하여 성능을 최적화한다.

1. **현재 트리:** 현재 화면에 보이는 상태를 나타내는 트리이다.
2. **작업용 트리:** 다음 화면을 위해 메모리 상에서 준비 중인 트리이다.
3. **전환:** 작업용 트리가 완성되면 리액트는 단순히 포인터를 교체하여 화면을 즉시 업데이트한다. 이를 통해 깜박임을 방지하고, 작업 도중 우선순위가 높은 일이 들어오면 진행 중인 작업용 트리를 버릴 수도 있다.

## 5. 파이버 재조정 단계

### 1) 렌더링 단계

메모리 상에서 새로운 상태의 트리를 계산하는 단계로, 사용자에게 보이지 않기 때문에 필요에 따라 중단하거나 재시작할 수 있다.

- **beginWork:** 트리를 위에서 아래로 내려가며 변경 사항이 있는 파이버에 업데이트 필요 플래그를 설정한다.
- **completeWork:** 트리 아래에서 다시 위로 올라오며, 실제 DOM 엘리먼트의 트리를 메모리 상에 구성한다.
- **Lanes:** 업데이트의 우선순위를 결정한다. 사용자 입력처럼 긴급한 작업이 낮은 순위의 작업보다 먼저 처리되도록 관리한다.

### 2) 커밋 단계

계산된 변경 사항을 실제 브라우저 DOM에 직접 반영하는 단계이다. 이 단계는 동기적으로 실행되며 중단할 수 없다.

- **변형 단계:** 실제 DOM 노드를 추가, 수정, 삭제하는 작업을 수행한다.
- **레이아웃 단계:** DOM 업데이트 후 실제 레이아웃 수치를 계산하며, 수명 주기 메서드나 레이아웃 효과가 실행된다.

## 6. 재조정 중 발생하는 효과

| **종류**          | **설명**                                                              |
| ----------------- | --------------------------------------------------------------------- |
| **배치 효과**     | 새 노드가 DOM에 추가될 때 발생한다.                                   |
| **업데이트 효과** | 기존 노드의 정보나 상태가 변경될 때 발생한다.                         |
| **삭제 효과**     | 노드가 DOM에서 제거될 때 발생한다.                                    |
| **레이아웃 효과** | 브라우저가 화면을 그리기 직전에 실행된다. (`useLayoutEffect`)         |
| **패시브 효과**   | 브라우저가 화면을 그린 후에 실행되는 비동기적 효과이다. (`useEffect`) |
