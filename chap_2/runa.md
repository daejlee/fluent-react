# 2 - JSX

> JSX는 HTML이 아닌 **자바스크립트로 UI 트리를 정의하기 위한 문법 확장**이다

## 1. JSX란?

- JSX는 **자바스크립트 문법 확장(Syntax Extension)**
- 브라우저가 이해하지 못하며 **컴파일 단계에서 순수 JS로 변환**됨

```tsx
const element = <h1>Hello</h1>;
```

⬇︎

```jsx
const element = React.createElement("h1", null, "Hello");
```

**⇒ 함수 호출을 더 읽기 쉽게 쓰는 문법**

---

## 2. JSX는 왜 XML처럼 생겼을까

- HTML / XML과 **매우 유사한 문법**
- 오직 **컴파일러가 해석하기 위한 표현 방식**

```tsx
<MyComponent title="Hello">
  <span>World</span>
</MyComponent>
```

### 왜 굳이 XML 같은 모양을 선택했을까?

```jsx
{
type:"div",
props: {children: [...] }
}
// 그냥 JS 객체로 한다면?
```

**A. UI는 ‘트리 구조’를 사람이 한눈에 읽어야 하기 때문**

- 개발자는 이미 HTML 트리에 익숙
- JSX는 새로운 UI 언어를 만들지 않고 익숙한 형태(HTML,XML)를 재사용

⇒ UI 구조를 코드만 봐도 즉시 파악 가능

---

## 3. JSX 프라그마

> 코드를 어떤 함수 호출로 바꿀 것인지를 컴파일러에 알려주는 지시자

기본 프라그마:

```jsx
/** @jsx React.createElement */
```

```tsx
<h1>Hello</h1>
```

컴파일 시

```jsx
React.createElement("h1", null, "Hello");
```

- 최신 리액트에서는 `import React from 'react'` 생략 가능
  - 컴파일러가 자동으로 런타임 주입
- 프라그마가 사라진 건 아니고 컴파일러가 대신 처리
- JSX는 리액트 전용 기술은 아님 (어떤 함수로 변환되느냐에 따라 다르다)

---

## 4. JSX는 표현식이다

- JSX의 `{}` 안에는 **값으로 평가되는 표현식만 가능**

가능한 예시

```tsx
{a + b}
{isLogin ?<Home /> :<Login />}
{items.map(item =><likey={item.id}>{item.name}</li>)}
```

불가능한 예시

```tsx
{
  if (a > b) {
    return3;
  }
}
```

### 왜 statement를 금지했을까?

- statement는 값을 반환하지 않음
- JSX는 UI 결과만 표현해야 함

⇒ 조건 분기는 **렌더링 이전**에 처리하도록 유도

---

## 5. JSX와 HTML의 차이

- `class` → `className`
- `for` → `htmlFor`
- 모든 태그는 닫혀야 함
- 하나의 루트 엘리먼트만 반환

⇒ JSX는 문자열이 아니라 **정적인 트리 구조**이기 때문

---

## 6. JSX의 장점

### 1) 가독성

- `createElement` 중첩 제거
- 코드만 봐도 UI 구조가 드러남

### 2) 보안 (XSS 방어)

- 문자열 자동 escape
- `<`, `>` 같은 위험 문자 보호

### 3) 컴포넌트 기반 설계 유도

- UI를 재사용 가능한 단위로 분리
- **의미 단위 컴포넌트**

---

## 7. JSX의 단점

- 학습 비용
- 빌드 도구 필수
- 관심사 혼합 논쟁
  - 관심사는 파일이 아니라 UI가 수행하는 역할 단위로 봐야 함

---

## 결론

- JSX는 HTML도 XML도 아니고 JS 표현식으로 **UI 트리를 정의하는 문법**
- XML과 흡사한 문법은 **가독성과 인지 비용 감소**를 위한 선택
- JSX 프라그마는 JSX의 실체가 **함수 호출**임을 드러냄
- JSX의 핵심 가치는 성능이 아니라 **가독성, 보안, 추론 가능성**

# 3 - 가상 DOM

## 1. 가상 DOM이란

- 실제 DOM의 복사본이 아님
- UI를 표현하는 가벼운 자바스크립트 객체 트리
- 리액트는 상태가 바뀔 때마다 실제 DOM이 아니라 가상 DOM을 먼저 업데이트

```jsx
const element = React.createElement("h1", null, "Hello");
```

내부적으로 만들어지는 형태

```jsx
{
  type: "h1",
  props: {
    children: "Hello"
  }
}
```

**⇒ UI를 그리는 명령이 아니라 상태를 설명하는 데이터로 다룬다**

---

## 2. 실제 DOM의 문제

### 1) 성능

- DOM 변경 시마다 브라우저는 스타일 계산, reflow, repaint 발생
- 단순 조회처럼 보이는 코드도 비용이 큼

```jsx
const width = element.offsetWidth; // reflow 발생 가능
```

⇒ DOM 트리가 클수록 비용이 폭발

### 2) 직접 조작의 복잡성

- DOM API는 **명령형**
- 언제, 어디를, 어떻게 바꿀지 전부 개발자가 책임짐
- 상태가 늘어날수록 분기 증가, 순서 의존

### 3) 예측 불가능성

- 작은 변경이 큰 레이아웃 재계산을 유발할 수 있음
- 성능 병목이 코드만 보고는 알 수 없음

---

## 3. 가상 DOM의 해결 방식

> 실제 DOM을 건드리기 전에 모든 변경을 메모리에서 시뮬레이션

1. 상태 변경
2. 새로운 가상 DOM 트리 생성
3. 이전 가상 DOM과 비교(diff)
4. 실제 DOM에 **최소 변경만 반영**

```
이전 UI 상태
      ↓
새 가상 DOM 트리
      ↓
diff 계산
      ↓
실제 DOM 최소 업데이트
```

**⇒ 느린 DOM 작업은 줄이고 빠른 JS 연산으로 계산을 대체**

---

## 4. 재조정(Reconciliation)

> 두 가상 DOM 트리를 비교해 실제 DOM에 반영할 변경만 골라내는 과정

- 리액트는 완벽한 트리 비교를 하지 않는 대신 휴리스틱 기반 규칙을 사용

대표 규칙

- 타입이 같으면 재사용
- 타입이 다르면 하위 트리 전부 교체
- 리스트는 `key`로 동일성 판단

⇒ 정확성보다는 속도와 예측 가능성을 택한 설계

⇒ 리액트는 **UI를 위한 엔지니어링 선택**을 함

---

## 5. Batching

```jsx
setCount((c) => c + 1);
setCount((c) => c + 1);
setCount((c) => c + 1);
```

- 실제 DOM을 직접 썼다면 DOM 업데이트 3번

리액트는

- 가상 DOM에서 먼저 계산하여 `count + 3` 만 반영
- DOM 업데이트 1번

⇒ 가상 DOM은 중간 상태를 전부 숨김

---

## 6. 가상 DOM의 오해

- 가상 DOM은 무조건 빠른 것이 아니다
- 단순 UI에서는 오히려 오버헤드
- 복잡한 UI에서 변경을 통제 가능하게 만들고 성능 특성을 예측 가능하게 함

---

## 결론

- 가상 DOM은 빠르게 만들기 위해서가 아니라, 개발자가 대규모 UI를 감당할 수 있게 만들기 위한 설계 장치
- 실제 DOM의 높은 비용, 명령형 복잡성, 예측 불가능성을 가리기 위한 추상화
- 리액트는 UI를 데이터처럼 다루게 만들고, DOM을 프레임워크의 책임으로 가져감
