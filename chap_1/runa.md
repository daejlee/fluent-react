# 1 - 입문자를 위한 지식

## 1. 리액트는 왜 필요했을까

> 웹은 더 즉각적으로 반응해야 했는데, 기존 방식은 그걸 감당 못 했다

### 당시 웹이 겪던 핵심 문제 3가지

### 1) 성능

- DOM이 업데이트 될 때마다 무거운 작업이 일어나며, DOM 트리가 커질수록 비용은 기하급수적으로 증가함
- DOM 접근과 업데이트가 잦아질수록 성능 병목으로 이어짐
- 컴포넌트 수와 상호작용이 늘어나는 순간 구조적 문제가 드러나 즉각적인 성능 저하를 일으킴

### 2) 신뢰성

- 상태가 여러 곳에 분산되어 한 화면의 현재 상태를 한눈에 파악할 방법이 없음
- 동일한 데이터가 여러 곳에 존재하면서, 한쪽만 업데이트되는 일이 잦음 → UI 불일치 버그 발생
- 코드가 커질수록 문제가 생겼을 때 화면이 왜 이렇게 됐는지 알 수가 없음

### 3) 보안

- 사용자 입력이나 서버 응답을 그대로 DOM에 넣는 방식은 XSS 같은 보안 취약점을 만들기 쉬웠음
- XSS, CSRF 방어 부담이 개발자에게 전가됨

**⇒ UI 업데이트가 많아질수록, 코드의 추론 가능성이 급격히 무너졌다**

---

## 2. 리액트 이전의 접근 방식들

### jQuery

- DOM 직접 조작, 명령형 코드가 곳곳에 흩어짐
- 상태라는 개념 자체가 없고 화면은 이벤트 발생의 결과일 뿐임
- 현재 화면이 어떤 상태인지 설명할 수 있는 단일 모델이 존재하지 않음

```jsx
$("#btn").click(() => {
  $("#loading").show();
  $("#result").text(data);
});
```

**⇒ UI 상태의 전체 그림을 볼 수 없다는 명확한 문제가 있다**

---

### Backbone / Knockout

- 상태 개념을 도입
- 옵저버블, 모델, 뷰 모델 등장 → 상태가 바뀌면 UI가 갱신

하지만

- 상태 변경 흐름이 암묵적
- 어디서 값이 바뀌는지 코드를 보고 추적이 어려움
- 보일러플레이트 증가

⇒ **상태는 생겼지만 통제되지 않았다**

---

### AngularJS

- 양방향 바인딩
- 구조화된 프레임워크

장점:

- 빠른 개발
- 초기 생산성

치명적 단점:

- 상태 변경의 **암묵성**
- 디버깅 난이도 증가
- 규모 커질수록 예측 불가

**⇒ 여전히 상태 변화의 흐름이 눈에 보이지 않았다**

---

## 3. 리액트의 관점 전환

> 이 상태라면 화면이 어떻게 보여야 하는가? → UI를 결과로 보는 리액트의 철학

---

### 1) 선언형 UI

```jsx
{
  isLoading ? <Spinner /> : <Result />;
}
```

- DOM 조작, 업데이트 로직 없음
- 상태에 따른 UI의 모습만 정의

**⇒ UI는 명령이 아닌 결과물이다**

---

### 2) 컴포넌트 모델

- UI를 재사용 가능한 함수로 분해
- 컴포넌트는 입력(props, state)을 받아 결과(UI)를 반환하는 함수

UI를 작은 단위로 나눔에 따라

- 동일한 컴포넌트는 시간에 따라 추적 가능
- **최적화** 수행이 가능해지는 전제가 생김 (메모이제이션, 배치 업데이트, 재조정 등)

---

### 3) Virtual DOM

> Virtual DOM은 성능 기술이 아니라 일관성 기술이다

- 이전 UI와 다음 UI의 차이를 계산하여 예측 가능한 방식으로 적용
- 어디가 바뀌었는지를 개발자가 책임지지 않음

---

## 4. 플럭스 아키텍처

> 상태가 어디서, 왜, 어떻게 바뀌는지 알 수 없던 문제를 해결하려 함

---

### 단방향 데이터 흐름

```
Action → Dispatcher → Store → View
```

- 상태 변경은 반드시 명시적인 사건을 통해서만 일어남
- 상태는 Store에만 존재

```jsx
{type:'ADD_TODO',text:'Learn Flux' }
```

### 왜 중요한가?

- 상태 변화를 시간 순서대로 추적 가능
- 테스트, 디버깅, 리팩터링 용이
- 이 구조가 이후 훅, 상태 관리, 렌더링 최적화의 전제가 됨

---

## 결론

> 리액트는 상태 변화에 대한 사고 방식을 바꾼 도구

- UI는 DOM 조작의 결과가 아니라 상태의 표현이며 함수이다
- 상태 변경은 예측 가능해야 한다
- 데이터 흐름은 눈에 보여야 한다
- 그래야 규모가 커져도 사람이 통제할 수 있다
